// Code generated by https://github.com/zhufuyi/sponge

package handler

import (
	"context"
	"errors"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/zhufuyi/sponge/pkg/gin/middleware"
	"github.com/zhufuyi/sponge/pkg/mysql/query"
	"strings"
	"time"

	communityV1 "community/api/community/v1"
	"community/internal/cache"
	"community/internal/config"
	"community/internal/dao"
	"community/internal/ecode"
	"community/internal/model"

	"github.com/zhufuyi/pkg/email"
	"github.com/zhufuyi/pkg/gocrypto"
	"github.com/zhufuyi/sponge/pkg/jwt"
	"github.com/zhufuyi/sponge/pkg/krand"
	"github.com/zhufuyi/sponge/pkg/logger"
	"github.com/zhufuyi/sponge/pkg/utils"

	"github.com/jinzhu/copier"
)

var emailWhiteList = map[string]struct{}{
	"foo@bar.com":   {},
	"foo1@bar.com":  {},
	"foo2@bar.com":  {},
	"foo3@bar.com":  {},
	"123456@qq.com": {},
}

var _ communityV1.UserServiceLogicer = (*userServiceHandler)(nil)

type userServiceHandler struct {
	iDao                 dao.UserDao
	emailVerifyCodeCache cache.EmailVerifyCodeCache
	userTokenCache       cache.UserTokenCache
	emailCli             *email.Client
}

// NewUserServiceHandler create a handler
func NewUserServiceHandler() communityV1.UserServiceLogicer {
	emailCli, err := email.Init(config.Get().Email.Username, config.Get().Email.Password)
	if err != nil {
		panic(err)
	}

	return &userServiceHandler{
		iDao: dao.NewUserDao(
			model.GetDB(),
			cache.NewUserCache(model.GetCacheType()),
		),
		emailVerifyCodeCache: cache.NewEmailVerifyCodeCache(model.GetCacheType()),
		userTokenCache:       cache.NewUserTokenCache(model.GetCacheType()),
		emailCli:             emailCli,
	}
}

// 检查邮箱是否已经注册过
func (h *userServiceHandler) checkEmailExist(ctx context.Context, email string) (*model.User, error) {
	data, err := h.iDao.GetByEmail(ctx, email)
	if err != nil {
		if errors.Is(err, model.ErrRecordNotFound) {
			return nil, model.ErrRecordNotFound
		}
		return nil, ecode.InternalServerError.Err()
	}

	return data, nil
}

// SendEmailVerifyCode 发送邮件验证码
func (h *userServiceHandler) SendEmailVerifyCode(ctx context.Context, req *communityV1.SendEmailVerifyCodeRequest) (*communityV1.SendEmailVerifyCodeReply, error) {
	c := ctx.(*gin.Context)
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.GCtxRequestIDField(c))
		return nil, ecode.InvalidParams.Err()
	}

	// 检查邮箱是否已经注册过
	data, _ := h.iDao.GetByEmail(ctx, req.Email)
	if data != nil && data.ID > 0 {
		logger.Warn("email is already in use", middleware.GCtxRequestIDField(c))
		return nil, ecode.AlreadyExists.Err()
	}

	verifyCode := krand.String(krand.R_All, 6)
	content := fmt.Sprintf(`
	注册验证码：%s
	有效时间10分钟。`, verifyCode)
	msg := &email.Message{
		To:          []string{req.Email},
		Cc:          nil,
		Subject:     "用户注册验证码",
		ContentType: "text/plain",
		Content:     content,
		Attach:      "",
	}

	if !isTestEmail(req.Email) {
		// 发送验证码到邮箱
		err = h.emailCli.SendMessage(msg)
		if err != nil {
			logger.Error("client.SendMessage error", logger.Err(err), middleware.GCtxRequestIDField(c))
			return nil, ecode.InternalServerError.Err()
		}
		// 缓存验证码
		err = h.emailVerifyCodeCache.Set(ctx, req.Email, verifyCode, cache.EmailVerifyCodeExpireTime)
		if err != nil {
			logger.Error("h.emailVerifyCodeCache.Set error", logger.Err(err), logger.String("email", req.Email), middleware.GCtxRequestIDField(c))
			return nil, ecode.InternalServerError.Err()
		}
	}

	return &communityV1.SendEmailVerifyCodeReply{}, nil
}

// Register 注册
func (h *userServiceHandler) Register(ctx context.Context, req *communityV1.RegisterRequest) (*communityV1.RegisterReply, error) {
	c := ctx.(*gin.Context)
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.GCtxRequestIDField(c))
		return nil, ecode.InvalidParams.Err()
	}

	if !isTestEmail(req.Email) {
		// 检查验证码是否存在
		verifyCode, err := h.emailVerifyCodeCache.Get(ctx, req.Email)
		if err != nil {
			logger.Warn("h.emailVerifyCodeCache.Set error", logger.Err(err), logger.String("email", req.Email), middleware.GCtxRequestIDField(c))
			return nil, ecode.ErrVerigyCodeUserService.Err()
		}
		if verifyCode != req.EmailCode {
			logger.Warn("email verify code error", logger.Err(err), logger.String("verifyCode", verifyCode), logger.String("emailCode", req.EmailCode), middleware.GCtxRequestIDField(c))
			return nil, ecode.ErrVerigyCodeUserService.Err()
		}
	}

	// 检查邮箱是否已经注册过
	data, err := h.iDao.GetByEmail(ctx, req.Email)
	if err != nil && !errors.Is(err, model.ErrRecordNotFound) {
		logger.Warn("h.checkEmailExist", logger.Err(err), logger.String("email", req.Email), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}
	if data != nil && data.ID > 0 {
		logger.Warn("email is already in use", middleware.GCtxRequestIDField(c))
		return nil, ecode.AlreadyExists.Err()
	}

	password, err := gocrypto.HashAndSaltPassword(req.Password)
	if err != nil {
		logger.Error("gocrypto.HashAndSaltPassword error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	user := &model.User{
		Password: password,
		Email:    req.Email,
		Name:     krand.String(krand.R_All, 10),
	}

	err = h.iDao.Create(ctx, user)
	if err != nil {
		logger.Error("h.iDao.Create error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	return &communityV1.RegisterReply{Id: user.ID}, nil
}

// Login 登录
func (h *userServiceHandler) Login(ctx context.Context, req *communityV1.LoginRequest) (*communityV1.LoginReply, error) {
	c := ctx.(*gin.Context)
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.GCtxRequestIDField(c))
		return nil, ecode.InvalidParams.Err()
	}

	// 检查邮箱是否已经注册过
	data, err := h.iDao.GetByEmail(ctx, req.Email)
	if err != nil || data == nil {
		logger.Warn("h.checkEmailExist error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.ErrNoAccountUserService.Err()
	}

	// 验证密码
	if !gocrypto.VerifyPassword(req.Password, data.Password) {
		logger.Warn("password error", middleware.GCtxRequestIDField(c))
		return nil, ecode.ErrPasswordUserService.Err()
	}

	// 判断是否已经登录过
	cacheToken, err := h.checkLogin(ctx, data.ID)
	if err != nil {
		logger.Error("h.userTokenCache.Get error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}
	if cacheToken != "" {
		return nil, ecode.ErrAlreadyLoginUserService.WithDetails("token: " + cacheToken).Err()
	}

	// 生成token
	token, err := jwt.GenerateToken(utils.Uint64ToStr(data.ID))
	if err != nil {
		logger.Error("jwt.GenerateToken error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	// 缓存token
	err = h.userTokenCache.Set(ctx, data.ID, token, cache.UserTokenExpireTime)
	if err != nil {
		logger.Error("h.userTokenCache.Set error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	// 更新登录相关状态
	user := &model.User{
		LoginAt: time.Now(),
		LoginIP: req.Ip,
	}
	user.ID = data.ID
	err = h.iDao.UpdateByID(ctx, user)
	if err != nil {
		logger.Warn("h.iDao.UpdateByID error", logger.Err(err), logger.Any("user", user), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	return &communityV1.LoginReply{
		Token: token,
		Id:    data.ID,
	}, nil
}

// Logout 登出
func (h *userServiceHandler) Logout(ctx context.Context, req *communityV1.LogoutRequest) (*communityV1.LogoutReply, error) {
	c := ctx.(*gin.Context)
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.GCtxRequestIDField(c))
		return nil, ecode.InvalidParams.Err()
	}

	claims, err := jwt.VerifyToken(req.Token)
	if err != nil {
		logger.Warn("jwt.VerifyToken error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.ErrTokenUserService.Err()
	}

	if claims.UID != utils.Uint64ToStr(req.Id) {
		logger.Warn("uid error", middleware.GCtxRequestIDField(c))
		return nil, ecode.ErrTokenUserService.Err()
	}

	// 判断是否已经登录过
	cacheToken, err := h.checkLogin(ctx, req.Id)
	if err != nil {
		logger.Error("h.userTokenCache.Get error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}
	if cacheToken == "" {
		return nil, ecode.ErrNotLoginUserService.Err()
	}

	if cacheToken != req.Token {
		logger.Warn("token error", middleware.GCtxRequestIDField(c))
		return nil, ecode.AccessDenied.Err()
	}

	err = h.userTokenCache.Del(ctx, req.Id)
	if err != nil {
		logger.Error("h.userTokenCache.Del error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	return &communityV1.LogoutReply{}, nil
}

// DeleteByID 删除用户
func (h *userServiceHandler) DeleteByID(ctx context.Context, req *communityV1.DeleteUserByIDRequest) (*communityV1.DeleteUserByIDReply, error) {
	c := ctx.(*gin.Context)
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.GCtxRequestIDField(c))
		return nil, ecode.InvalidParams.Err()
	}

	err = h.iDao.DeleteByID(ctx, req.Id)
	if err != nil {
		logger.Error("h.iDao.DeleteByID error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	_ = h.userTokenCache.Del(ctx, req.Id)

	return &communityV1.DeleteUserByIDReply{}, nil
}

// UpdateByID 更新用户
func (h *userServiceHandler) UpdateByID(ctx context.Context, req *communityV1.UpdateUserByIDRequest) (*communityV1.UpdateUserByIDReply, error) {
	c := ctx.(*gin.Context)
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.GCtxRequestIDField(c))
		return nil, ecode.InvalidParams.Err()
	}

	user := &model.User{
		Name:     req.Name,
		NickName: req.NickName,
		Phone:    req.Phone,
		Avatar:   req.Avatar,
		Gender:   int(req.Gender),
		Age:      int(req.Age),
		Birthday: req.Birthday,
	}
	user.ID = req.Id
	err = h.iDao.UpdateByID(ctx, user)
	if err != nil {
		logger.Error("h.iDao.UpdateByID error", logger.Err(err), logger.Any("user", user), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	return &communityV1.UpdateUserByIDReply{}, nil
}

// GetByID 用户详情
func (h *userServiceHandler) GetByID(ctx context.Context, req *communityV1.GetUserByIDRequest) (*communityV1.GetUserByIDReply, error) {
	c := ctx.(*gin.Context)
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.GCtxRequestIDField(c))
		return nil, ecode.InvalidParams.Err()
	}

	user, err := h.iDao.GetByID(ctx, req.Id)
	if err != nil {
		if errors.Is(err, model.ErrRecordNotFound) {
			logger.Warn("h.iDao.GetByID error", logger.Err(err), middleware.GCtxRequestIDField(c))
			return nil, ecode.NotFound.Err()
		}
		logger.Error("h.iDao.GetByID error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}
	userInfo, err := covertUser(user)
	if err != nil {
		logger.Error("covertUser error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.ErrGetByIDUserService.Err()
	}

	return &communityV1.GetUserByIDReply{UserInfo: userInfo}, nil
}

// List 获取用户列表
func (h *userServiceHandler) List(ctx context.Context, req *communityV1.ListUserRequest) (*communityV1.ListUserReply, error) {
	c := ctx.(*gin.Context)
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.GCtxRequestIDField(c))
		return nil, ecode.InvalidParams.Err()
	}

	params := &query.Params{}
	err = copier.Copy(params, req.Params)
	if err != nil {
		logger.Error("covertUser error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.ErrListUserService.Err()
	}
	params.Size = int(req.Params.Limit)

	records, total, err := h.iDao.GetByColumns(ctx, params)
	if err != nil {
		if strings.Contains(err.Error(), "query params error:") {
			logger.Warn("h.iDao.GetByColumns error", logger.Err(err), logger.Any("params", params), middleware.GCtxRequestIDField(c))
			return nil, ecode.InvalidParams.Err()
		}
		logger.Error("h.iDao.GetByColumns error", logger.Err(err), logger.Any("params", params), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	users := []*communityV1.User{}
	for _, record := range records {
		user, err := covertUser(record)
		if err != nil {
			logger.Warn("covertUser error", logger.Err(err), logger.Uint64("id", record.ID), middleware.GCtxRequestIDField(c))
			continue
		}
		users = append(users, user)
	}

	return &communityV1.ListUserReply{
		Total:     total,
		UserInfos: users,
	}, nil
}

// UpdatePassword 更新密码
func (h *userServiceHandler) UpdatePassword(ctx context.Context, req *communityV1.UpdatePasswordRequest) (*communityV1.UpdatePasswordReply, error) {
	c := ctx.(*gin.Context)
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.GCtxRequestIDField(c))
		return nil, ecode.InvalidParams.Err()
	}

	password, err := gocrypto.HashAndSaltPassword(req.Password)
	if err != nil {
		logger.Error("gocrypto.HashAndSaltPassword error", logger.Err(err), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	user := &model.User{
		Password: password,
	}
	user.ID = req.Id
	err = h.iDao.UpdateByID(ctx, user)
	if err != nil {
		logger.Error("h.iDao.UpdateByID error", logger.Err(err), logger.Any("user", user), middleware.GCtxRequestIDField(c))
		return nil, ecode.InternalServerError.Err()
	}

	return &communityV1.UpdatePasswordReply{}, nil
}

func (h *userServiceHandler) checkLogin(ctx context.Context, id uint64) (string, error) {
	cacheToken, err := h.userTokenCache.Get(ctx, id)
	if err != nil && !errors.Is(err, model.ErrCacheNotFound) {
		return "", err
	}

	return cacheToken, nil
}

func isTestEmail(email string) bool {
	_, ok := emailWhiteList[email]
	return ok
}

func covertUser(record *model.User) (*communityV1.User, error) {
	value := &communityV1.User{}
	err := copier.Copy(value, record)
	if err != nil {
		return nil, err
	}
	value.Id = record.ID
	value.CreatedAt = record.CreatedAt.Unix()
	value.UpdatedAt = record.UpdatedAt.Unix()
	value.LoginAt = record.LoginAt.Unix()
	return value, nil
}

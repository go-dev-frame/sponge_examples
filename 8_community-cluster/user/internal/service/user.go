// Code generated by https://github.com/zhufuyi/sponge

package service

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	userV1 "user/api/user/v1"
	"user/internal/cache"
	"user/internal/config"
	"user/internal/dao"
	"user/internal/ecode"
	"user/internal/model"

	"github.com/zhufuyi/pkg/email"
	"github.com/zhufuyi/pkg/gocrypto"
	"github.com/zhufuyi/sponge/pkg/grpc/interceptor"
	"github.com/zhufuyi/sponge/pkg/jwt"
	"github.com/zhufuyi/sponge/pkg/krand"
	"github.com/zhufuyi/sponge/pkg/logger"
	"github.com/zhufuyi/sponge/pkg/mysql/query"
	"github.com/zhufuyi/sponge/pkg/utils"

	"github.com/jinzhu/copier"
	"google.golang.org/grpc"
)

var emailWhiteList = map[string]struct{}{
	"foo@bar.com":   {},
	"foo1@bar.com":  {},
	"foo2@bar.com":  {},
	"foo3@bar.com":  {},
	"123456@qq.com": {},
}

func init() {
	registerFns = append(registerFns, func(server *grpc.Server) {
		userV1.RegisterUserServiceServer(server, NewUserServiceServer())
	})
}

var _ userV1.UserServiceServer = (*userService)(nil)

type userService struct {
	userV1.UnimplementedUserServiceServer

	iDao                 dao.UserDao
	emailVerifyCodeCache cache.EmailVerifyCodeCache
	userTokenCache       cache.UserTokenCache
	emailCli             *email.Client
}

// NewUserServiceServer create a server
func NewUserServiceServer() userV1.UserServiceServer {
	emailCli, err := email.Init(config.Get().Email.Username, config.Get().Email.Password)
	if err != nil {
		panic(err)
	}

	return &userService{
		iDao: dao.NewUserDao(
			model.GetDB(),
			cache.NewUserCache(model.GetCacheType()),
		),
		emailVerifyCodeCache: cache.NewEmailVerifyCodeCache(model.GetCacheType()),
		userTokenCache:       cache.NewUserTokenCache(model.GetCacheType()),
		emailCli:             emailCli,
	}
}

// 检查邮箱是否已经注册过
func (s *userService) checkEmailExist(ctx context.Context, email string) (*model.User, error) {
	data, err := s.iDao.GetByEmail(ctx, email)
	if err != nil {
		if errors.Is(err, model.ErrRecordNotFound) {
			return nil, model.ErrRecordNotFound
		}
		return nil, ecode.StatusInternalServerError.Err(ecode.Any("err", err))
	}

	return data, nil
}

// SendEmailVerifyCode 发送邮件验证码
func (s *userService) SendEmailVerifyCode(ctx context.Context, req *userV1.SendEmailVerifyCodeRequest) (*userV1.SendEmailVerifyCodeReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInvalidParams.Err()
	}
	ctx = interceptor.WrapServerCtx(ctx)

	// 检查邮箱是否已经注册过
	data, _ := s.iDao.GetByEmail(ctx, req.Email)
	if data != nil && data.ID > 0 {
		logger.Warn("email is already in use", interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusAlreadyExists.Err()
	}

	verifyCode := krand.String(krand.R_All, 6)
	content := fmt.Sprintf(`
	注册验证码：%s
	有效时间10分钟。`, verifyCode)
	msg := &email.Message{
		To:          []string{req.Email},
		Cc:          nil,
		Subject:     "用户注册验证码",
		ContentType: "text/plain",
		Content:     content,
		Attach:      "",
	}

	if !isTestEmail(req.Email) {
		// 发送验证码到邮箱
		err = s.emailCli.SendMessage(msg)
		if err != nil {
			logger.Error("client.SendMessage error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
			return nil, ecode.StatusInternalServerError.Err()
		}
		// 缓存验证码
		err = s.emailVerifyCodeCache.Set(ctx, req.Email, verifyCode, cache.EmailVerifyCodeExpireTime)
		if err != nil {
			logger.Error("s.emailVerifyCodeCache.Set error", logger.Err(err), logger.String("email", req.Email), interceptor.ServerCtxRequestIDField(ctx))
			return nil, ecode.StatusInternalServerError.Err()
		}
	}

	return &userV1.SendEmailVerifyCodeReply{}, nil
}

// Register 注册
func (s *userService) Register(ctx context.Context, req *userV1.RegisterRequest) (*userV1.RegisterReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInvalidParams.Err()
	}
	ctx = interceptor.WrapServerCtx(ctx)

	if !isTestEmail(req.Email) {
		// 检查验证码是否存在
		verifyCode, err := s.emailVerifyCodeCache.Get(ctx, req.Email)
		if err != nil {
			logger.Warn("s.emailVerifyCodeCache.Set error", logger.Err(err), logger.String("email", req.Email), interceptor.ServerCtxRequestIDField(ctx))
			return nil, ecode.StatusVerigyCodeUserService.Err()
		}
		if verifyCode != req.EmailCode {
			logger.Warn("email verify code error", logger.Err(err), logger.String("verifyCode", verifyCode), logger.String("emailCode", req.EmailCode), interceptor.ServerCtxRequestIDField(ctx))
			return nil, ecode.StatusVerigyCodeUserService.Err()
		}
	}

	// 检查邮箱是否已经注册过
	data, err := s.iDao.GetByEmail(ctx, req.Email)
	if err != nil && !errors.Is(err, model.ErrRecordNotFound) {
		logger.Warn("s.checkEmailExist", logger.Err(err), logger.String("email", req.Email), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err(ecode.Any("err", err))
	}
	if data != nil && data.ID > 0 {
		logger.Warn("email is already in use", interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusAlreadyExists.Err()
	}

	password, err := gocrypto.HashAndSaltPassword(req.Password)
	if err != nil {
		logger.Error("gocrypto.HashAndSaltPassword error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	user := &model.User{
		Password: password,
		Email:    req.Email,
		Name:     krand.String(krand.R_All, 10),
	}

	err = s.iDao.Create(ctx, user)
	if err != nil {
		logger.Error("s.iDao.Create error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	return &userV1.RegisterReply{Id: user.ID}, nil
}

// Login 登录
func (s *userService) Login(ctx context.Context, req *userV1.LoginRequest) (*userV1.LoginReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInvalidParams.Err()
	}
	ctx = interceptor.WrapServerCtx(ctx)

	// 检查邮箱是否已经注册过
	data, err := s.iDao.GetByEmail(ctx, req.Email)
	if err != nil || data == nil {
		logger.Warn("s.checkEmailExist error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusPasswordUserService.Err()
	}

	// 验证密码
	if !gocrypto.VerifyPassword(req.Password, data.Password) {
		logger.Warn("password error", interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusPasswordUserService.Err()
	}

	// 判断是否已经登录过
	isLogin, err := s.checkLogin(ctx, data.ID)
	if err != nil {
		logger.Error("h.userTokenCache.Get error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}
	if isLogin {
		return nil, ecode.StatusAlreadyLoginUserService.Err()
	}

	// 生成token
	token, err := jwt.GenerateToken(utils.Uint64ToStr(data.ID))
	if err != nil {
		logger.Error("jwt.GenerateToken error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	// 缓存token
	err = s.userTokenCache.Set(ctx, data.ID, token, cache.UserTokenExpireTime)
	if err != nil {
		logger.Error("s.userTokenCache.Set error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	// 更新登录相关状态
	user := &model.User{
		LoginAt: time.Now(),
		LoginIP: req.Ip,
	}
	user.ID = data.ID
	err = s.iDao.UpdateByID(ctx, user)
	if err != nil {
		logger.Warn("s.iDao.UpdateByID error", logger.Err(err), logger.Any("user", user), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	return &userV1.LoginReply{
		Token: token,
		Id:    data.ID,
	}, nil
}

// Logout 登出
func (s *userService) Logout(ctx context.Context, req *userV1.LogoutRequest) (*userV1.LogoutReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInvalidParams.Err()
	}
	ctx = interceptor.WrapServerCtx(ctx)

	claims, err := jwt.ParseToken(req.Token)
	if err != nil {
		logger.Warn("jwt.VerifyToken error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusTokenUserService.Err()
	}

	if claims.UID != utils.Uint64ToStr(req.Id) {
		logger.Warn("uid error", interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusTokenUserService.Err()
	}

	// 判断是否已经登录过
	isLogin, err := s.checkLogin(ctx, req.Id)
	if err != nil {
		logger.Error("h.userTokenCache.Get error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}
	if !isLogin {
		return nil, ecode.StatusNotLoginUserService.Err()
	}

	err = s.userTokenCache.Del(ctx, req.Id)
	if err != nil {
		logger.Error("s.userTokenCache.Del error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	return &userV1.LogoutReply{}, nil
}

// DeleteByID 删除用户
func (s *userService) DeleteByID(ctx context.Context, req *userV1.DeleteUserByIDRequest) (*userV1.DeleteUserByIDReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInvalidParams.Err()
	}
	ctx = interceptor.WrapServerCtx(ctx)

	err = s.iDao.DeleteByID(ctx, req.Id)
	if err != nil {
		logger.Error("s.iDao.DeleteByID error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	_ = s.userTokenCache.Del(ctx, req.Id)

	return &userV1.DeleteUserByIDReply{}, nil
}

// UpdateByID 更新用户
func (s *userService) UpdateByID(ctx context.Context, req *userV1.UpdateUserByIDRequest) (*userV1.UpdateUserByIDReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInvalidParams.Err()
	}
	ctx = interceptor.WrapServerCtx(ctx)

	user := &model.User{
		Name:     req.Name,
		NickName: req.NickName,
		Phone:    req.Phone,
		Avatar:   req.Avatar,
		Gender:   int(req.Gender),
		Age:      int(req.Age),
		Birthday: req.Birthday,
	}
	user.ID = req.Id
	err = s.iDao.UpdateByID(ctx, user)
	if err != nil {
		logger.Error("s.iDao.UpdateByID error", logger.Err(err), logger.Any("user", user), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	return &userV1.UpdateUserByIDReply{}, nil
}

// GetByID 获取用户详情
func (s *userService) GetByID(ctx context.Context, req *userV1.GetUserByIDRequest) (*userV1.GetUserByIDReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInvalidParams.Err()
	}
	ctx = interceptor.WrapServerCtx(ctx)

	user, err := s.iDao.GetByID(ctx, req.Id)
	if err != nil {
		if errors.Is(err, model.ErrRecordNotFound) {
			logger.Warn("s.iDao.GetByID error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
			return nil, ecode.StatusNotFound.Err()
		}
		logger.Error("s.iDao.GetByID error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}
	userInfo, err := covertUser(user)
	if err != nil {
		logger.Error("covertUser error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusGetByIDUserService.Err()
	}

	return &userV1.GetUserByIDReply{UserInfo: userInfo}, nil
}

// List 获取用户列表
func (s *userService) List(ctx context.Context, req *userV1.ListUserRequest) (*userV1.ListUserReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInvalidParams.Err()
	}
	ctx = interceptor.WrapServerCtx(ctx)

	params := &query.Params{}
	err = copier.Copy(params, req.Params)
	if err != nil {
		logger.Error("covertUser error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusListUserService.Err()
	}
	params.Size = int(req.Params.Limit)

	records, total, err := s.iDao.GetByColumns(ctx, params)
	if err != nil {
		if strings.Contains(err.Error(), "query params error:") {
			logger.Warn("s.iDao.GetByColumns error", logger.Err(err), logger.Any("params", params), interceptor.ServerCtxRequestIDField(ctx))
			return nil, ecode.StatusInvalidParams.Err()
		}
		logger.Error("s.iDao.GetByColumns error", logger.Err(err), logger.Any("params", params), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.ToRPCErr()
	}

	users := []*userV1.User{}
	for _, record := range records {
		user, err := covertUser(record)
		if err != nil {
			logger.Warn("covertUser error", logger.Err(err), logger.Uint64("id", record.ID), interceptor.ServerCtxRequestIDField(ctx))
			continue
		}
		users = append(users, user)
	}

	return &userV1.ListUserReply{
		Total:     total,
		UserInfos: users,
	}, nil
}

// UpdatePassword 更新密码
func (s *userService) UpdatePassword(ctx context.Context, req *userV1.UpdatePasswordRequest) (*userV1.UpdatePasswordReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInvalidParams.Err()
	}
	ctx = interceptor.WrapServerCtx(ctx)

	password, err := gocrypto.HashAndSaltPassword(req.Password)
	if err != nil {
		logger.Error("gocrypto.HashAndSaltPassword error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	user := &model.User{
		Password: password,
	}
	user.ID = req.Id
	err = s.iDao.UpdateByID(ctx, user)
	if err != nil {
		logger.Error("s.iDao.UpdateByID error", logger.Err(err), logger.Any("user", user), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	return &userV1.UpdatePasswordReply{}, nil
}

// CheckLogin 判断是否登录
func (s *userService) CheckLogin(ctx context.Context, req *userV1.CheckLoginRequest) (*userV1.CheckLoginReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInvalidParams.Err()
	}

	token, err := model.GetRedisCli().Get(ctx, cache.GetUserTokenCacheKey(req.Id)).Result()
	if err != nil {
		logger.Warn("get token error", logger.Err(err), interceptor.ServerCtxRequestIDField(ctx))
		return nil, ecode.StatusInternalServerError.Err()
	}

	reply := &userV1.CheckLoginReply{}

	if len(token) > 11 {
		reply.IsLogin = true
		reply.TokenTails = token[len(token)-11 : len(token)-1]
	}

	return reply, nil
}

func (h *userService) checkLogin(ctx context.Context, id uint64) (bool, error) {
	result, err := model.GetRedisCli().Exists(ctx, cache.GetUserTokenCacheKey(id)).Result()
	if err != nil {
		return false, err
	}
	return result > 0, nil
}

func isTestEmail(email string) bool {
	_, ok := emailWhiteList[email]
	return ok
}

func covertUser(record *model.User) (*userV1.User, error) {
	value := &userV1.User{}
	err := copier.Copy(value, record)
	if err != nil {
		return nil, err
	}
	value.Id = record.ID
	value.CreatedAt = record.CreatedAt.Unix()
	value.UpdatedAt = record.UpdatedAt.Unix()
	value.LoginAt = record.LoginAt.Unix()
	return value, nil
}

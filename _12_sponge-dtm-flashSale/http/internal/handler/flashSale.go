// Code generated by https://github.com/zhufuyi/sponge

package handler

import (
	"context"
	"errors"
	"strconv"
	"time"

	"github.com/dtm-labs/dtmcli"
	"github.com/dtm-labs/dtmcli/dtmimp"
	"github.com/go-redis/redis/v8"

	"github.com/zhufuyi/sponge/pkg/gin/middleware"
	"github.com/zhufuyi/sponge/pkg/krand"
	"github.com/zhufuyi/sponge/pkg/logger"

	flashSaleV1 "flashSale/api/flashSale/v1"
	"flashSale/internal/config"
	"flashSale/internal/ecode"
	"flashSale/pkg/goredis"
)

var _ flashSaleV1.FlashSaleLogicer = (*flashSaleHandler)(nil)

type flashSaleHandler struct {
	rdb *redis.Client
}

// NewFlashSaleHandler create a handler
func NewFlashSaleHandler() flashSaleV1.FlashSaleLogicer {
	return &flashSaleHandler{
		rdb: goredis.GetRedisCli(),
	}
}

// SetProductStock 设置库存数量
func (h *flashSaleHandler) SetProductStock(ctx context.Context, req *flashSaleV1.SetProductStockRequest) (*flashSaleV1.SetProductStockReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.CtxRequestIDField(ctx))
		return nil, ecode.InvalidParams.Err()
	}

	stockKey := getStockKey(req.ProductID)
	_, err = goredis.GetRedisCli().Set(context.Background(), stockKey, req.Stock, 24*time.Hour).Result()
	if err != nil {
		logger.Warn("SetProductStock err", logger.Err(err), logger.Any("req", req), middleware.CtxRequestIDField(ctx))
		return nil, ecode.InternalServerError.Err()
	}

	return &flashSaleV1.SetProductStockReply{}, nil
}

// FlashSale 秒杀抢购
func (h *flashSaleHandler) FlashSale(ctx context.Context, req *flashSaleV1.FlashSaleRequest) (*flashSaleV1.FlashSaleReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.CtxRequestIDField(ctx))
		return nil, ecode.InvalidParams.ErrToHTTP()
	}

	gid := newGid()
	callbackFlashSaleAddr := getCallbackFlashSaleAddr()
	redisQueryPreparedURL := callbackFlashSaleAddr + "/api/v1/flashSale/redisQueryPrepared"
	submitOrderURL := callbackFlashSaleAddr + "/api/v1/flashSale/sendSubmitOrderNotify"
	submitOrderReq := &flashSaleV1.SendSubmitOrderNotifyRequest{
		UserID:       req.UserID,
		ProductID:    req.ProductID,
		ProductCount: 1,
		Amount:       req.Amount,
		CouponID:     0,
		OrderID:      gid,
		RequestID:    middleware.CtxRequestID(ctx),
	}
	header := map[string]string{middleware.HeaderXRequestIDKey: middleware.CtxRequestID(ctx)}

	// 创建二阶段消息事务，1.检查库存是充足， 2.扣减库存，创建订单
	msg := dtmcli.NewMsg(config.Get().Dtm.Server, gid)
	msg.Add(submitOrderURL, submitOrderReq)
	msg.BranchHeaders = header
	err = msg.DoAndSubmit(redisQueryPreparedURL, func(bb *dtmcli.BranchBarrier) error {
		return bb.RedisCheckAdjustAmount(h.rdb, getStockKey(req.ProductID), -1, 86400)
	})
	if err != nil {
		if errors.Is(err, dtmimp.ErrFailure) {
			return nil, ecode.Conflict.ErrToHTTP("已售罄，欢迎下次再来抢购。") // 返回409错误码
		}
		logger.Error("DoAndSubmit error", logger.Err(err), logger.Any("req", req), middleware.CtxRequestIDField(ctx))
		return nil, ecode.InternalServerError.ErrToHTTP()
	}

	logger.Info("flashSale success", logger.String("gid", gid), logger.String("trans type", "msg"), middleware.CtxRequestIDField(ctx))

	return &flashSaleV1.FlashSaleReply{}, nil
}

// SendSubmitOrderNotify 发送提交订单通知
func (h *flashSaleHandler) SendSubmitOrderNotify(ctx context.Context, req *flashSaleV1.SendSubmitOrderNotifyRequest) (*flashSaleV1.SendSubmitOrderNotifyReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.CtxRequestIDField(ctx))
		return nil, ecode.Conflict.ErrToHTTP() // 返回409错误码
	}
	req.RequestID = middleware.CtxRequestID(ctx)

	// 在这里发送消息(例如rabbitmq、kafka)，通知订单创建，因为没有子事务屏障，消费端需要做幂等处理
	logger.Info("SendSubmitOrderNotify success", logger.String("topic", "flash-sale-order"), middleware.CtxRequestIDField(ctx))

	return &flashSaleV1.SendSubmitOrderNotifyReply{}, nil
}

// RedisQueryPrepared 反查redis数据
func (h *flashSaleHandler) RedisQueryPrepared(ctx context.Context, req *flashSaleV1.RedisQueryPreparedRequest) (*flashSaleV1.RedisQueryPreparedReply, error) {
	c, ctx := middleware.AdaptCtx(ctx)
	values := c.Request.URL.Query()

	bb, err := dtmcli.BarrierFromQuery(values)
	if err != nil {
		logger.Warn("BarrierFromQuery error", logger.Err(err), middleware.CtxRequestIDField(ctx))
		return nil, ecode.InternalServerError.ErrToHTTP()
	}
	err = bb.RedisQueryPrepared(h.rdb, 7*86400)
	if err != nil {
		logger.Error("RedisQueryPrepared error", logger.Err(err), middleware.CtxRequestIDField(ctx))
		return nil, ecode.InternalServerError.ErrToHTTP()
	}

	return &flashSaleV1.RedisQueryPreparedReply{}, nil
}

func newGid() string {
	return krand.NewSeriesID()
}

func getCallbackFlashSaleAddr() string {
	port := config.Get().HTTP.Port
	flashSaleCfg := config.Get().Dtm.CallbackAddr.FlashSale
	if flashSaleCfg.Port != 0 {
		port = flashSaleCfg.Port
	}
	return flashSaleCfg.Scheme + "://" + flashSaleCfg.Host + ":" + strconv.Itoa(port)
}

func getStockKey(productID uint64) string {
	return "stock:product_id:" + strconv.FormatUint(productID, 10)
}

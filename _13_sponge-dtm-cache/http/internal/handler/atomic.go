// Code generated by https://github.com/zhufuyi/sponge

package handler

import (
	"context"
	"database/sql"
	"errors"
	"time"

	"github.com/dtm-labs/dtmcli"
	"github.com/dtm-labs/rockscache"

	"github.com/zhufuyi/sponge/pkg/gin/middleware"
	"github.com/zhufuyi/sponge/pkg/logger"
	"github.com/zhufuyi/sponge/pkg/utils"

	stockV1 "stock/api/stock/v1"
	"stock/internal/config"
	"stock/internal/dao"
	"stock/internal/ecode"
	"stock/internal/model"
)

var _ stockV1.AtomicLogicer = (*atomicHandler)(nil)

type atomicHandler struct {
	db          *sql.DB
	cacheClient *rockscache.Client
}

// NewAtomicHandler create a handler
func NewAtomicHandler() stockV1.AtomicLogicer {
	return &atomicHandler{
		db:          model.GetSDB(),
		cacheClient: model.GetRockscacheClient(),
	}
}

// Update 更新数据，保证DB与缓存操作的原子性。
func (h *atomicHandler) Update(ctx context.Context, req *stockV1.UpdateAtomicRequest) (*stockV1.UpdateAtomicRequestReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.CtxRequestIDField(ctx))
		return nil, adaptErr(err)
	}

	gid := newGid()
	callbackStockAddr := getCallbackStockAddr()
	queryPreparedURL := callbackStockAddr + "/api/v1/stock/queryPrepared"
	deleteCacheURL := callbackStockAddr + "/api/v1/stock/deleteCache"
	deleteCacheBody := &stockV1.DeleteCacheRequest{
		Key: getStockCacheKey(req.Id),
	}
	stock := &model.Stock{
		ID:    req.Id,
		Stock: uint(req.Stock),
	}

	msg := dtmcli.NewMsg(config.Get().Dtm.Server, gid)
	msg.Add(deleteCacheURL, deleteCacheBody)
	msg.TimeoutToFail = 3
	err = msg.DoAndSubmit(queryPreparedURL, func(bb *dtmcli.BranchBarrier) error {
		return bb.CallWithDB(h.db, func(tx *sql.Tx) error {
			return dao.UpdateStockInTx(tx, stock)
		})
	})
	if err != nil {
		logger.Warn("msg.DoAndSubmit error", logger.Err(err), logger.Any("req", req), middleware.CtxRequestIDField(ctx))
		return nil, adaptErr(err)
	}

	logger.Info("更新数据，DB与缓存操作的原子性", logger.Any("dtm gid", gid))

	return &stockV1.UpdateAtomicRequestReply{}, nil
}

// Query  查询
func (h *atomicHandler) Query(ctx context.Context, req *stockV1.QueryAtomicRequest) (*stockV1.QueryAtomicReply, error) {
	err := req.Validate()
	if err != nil {
		logger.Warn("req.Validate error", logger.Err(err), logger.Any("req", req), middleware.CtxRequestIDField(ctx))
		return nil, ecode.InvalidParams.Err()
	}

	key := getStockCacheKey(req.Id)
	query := func() (string, error) {
		return dao.GetStockByID(h.db, req.Id)
	}

	value, err := h.cacheClient.Fetch(key, 300*time.Second, query)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ecode.NotFound.Err()
		}
		logger.Warn("fetch cache error", logger.Err(err), middleware.CtxRequestIDField(ctx))
		return nil, ecode.InternalServerError.Err()
	}

	return &stockV1.QueryAtomicReply{
		Stock: utils.StrToUint32(value),
	}, nil
}
